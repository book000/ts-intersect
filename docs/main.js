/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.drawRandom = exports.drawDefault = void 0;\nconst solution_1 = __webpack_require__(/*! ./solution */ \"./src/solution.ts\");\nconst examples = {\n    first: [\n        { x: 60, y: 60 },\n        { x: 180, y: 0 },\n        { x: 300, y: 60 },\n        { x: 300, y: 300 },\n        { x: 240, y: 180 },\n        { x: 210, y: 180 },\n        { x: 180, y: 240 },\n        { x: 150, y: 180 },\n        { x: 120, y: 180 },\n        { x: 60, y: 300 },\n    ],\n    second: [\n        { x: 300, y: 240 },\n        { x: 330, y: 220 },\n        { x: 330, y: 210 },\n        { x: 270, y: 90 },\n        { x: 230, y: 270 },\n        { x: 210, y: 90 },\n        { x: 180, y: 60 },\n        { x: 150, y: 90 },\n        { x: 140, y: 280 },\n        { x: 90, y: 90 },\n        { x: 30, y: 210 },\n    ],\n};\nfunction drawPolygon(data, container, color) {\n    const pol = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n    const str = data\n        .map(function (point) {\n        return point.x + \",\" + point.y;\n    })\n        .join(\" \");\n    pol.setAttribute(\"points\", str);\n    pol.style.fill = color;\n    container.appendChild(pol);\n}\nfunction drawAllPolygons(pol1, pol2) {\n    drawPolygon(pol1, document.querySelector(\"svg.base\"), \"navy\");\n    drawPolygon(pol2, document.querySelector(\"svg.base\"), \"yellow\");\n    (0, solution_1.intersect)(pol1, pol2).forEach(function (p) {\n        drawPolygon(p, document.querySelector(\"svg.intersections\"), \"red\");\n    });\n}\nfunction getTwoRandomPolygons(num1, num2) {\n    const twoPolygons = [[], []];\n    let x, y;\n    const nums = [num1, num2];\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < nums[i]; j++) {\n            x = Math.round(380 * Math.random() + 10);\n            y = Math.round(380 * Math.random() + 10);\n            twoPolygons[i].push({ x: x, y: y });\n        }\n    }\n    return twoPolygons;\n}\nfunction drawDefault() {\n    drawAllPolygons(examples.first, examples.second);\n}\nexports.drawDefault = drawDefault;\nfunction drawRandom() {\n    const svg1 = document.querySelector(\"svg.base\");\n    let base = svg1.getElementsByTagName(\"*\");\n    for (let i = base.length - 1; i >= 0; i--) {\n        svg1.removeChild(base[i]);\n    }\n    const svg2 = document.querySelector(\"svg.intersections\");\n    base = svg2.getElementsByTagName(\"*\");\n    for (let i = base.length - 1; i >= 0; i--) {\n        svg2.removeChild(base[i]);\n    }\n    const MAX = 100;\n    const MIN = 3;\n    const pol1 = document.getElementById(\"pol1\");\n    pol1.value = Math.round(parseInt(pol1.value)).toString();\n    if (parseInt(pol1.value) > MAX)\n        pol1.value = MAX.toString();\n    if (parseInt(pol1.value) < MIN)\n        pol1.value = MIN.toString();\n    const pol2 = document.getElementById(\"pol2\");\n    pol2.value = Math.round(parseInt(pol2.value)).toString();\n    if (parseInt(pol2.value) > MAX)\n        pol2.value = MAX.toString();\n    if (parseInt(pol2.value) < MIN)\n        pol2.value = MIN.toString();\n    const polygons = getTwoRandomPolygons(parseInt(pol1.value), parseInt(pol2.value));\n    drawAllPolygons(polygons[0], polygons[1]);\n}\nexports.drawRandom = drawRandom;\ndocument.getElementById(\"draw-button\").onclick = () => drawRandom();\ndrawDefault();\n\n\n//# sourceURL=webpack://ts-intersect/./src/index.ts?");

/***/ }),

/***/ "./src/solution.ts":
/*!*************************!*\
  !*** ./src/solution.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.intersect = exports.areaZtoY = void 0;\nfunction areaZtoY(fig) {\n    return fig.map(({ x, z }) => ({ x, y: z }));\n}\nexports.areaZtoY = areaZtoY;\nfunction intersect(fig1, fig2) {\n    const fig2a = alignPolygon(fig2, fig1);\n    if (!checkPolygons(fig1, fig2a)) {\n        throw new Error(\"checkPolygons failed\");\n    }\n    const edges = edgify(fig1, fig2a);\n    const polygons = polygonate(edges);\n    return filterPolygons(polygons, fig1, fig2a, \"intersect\");\n}\nexports.intersect = intersect;\nfunction alignPolygon(polygon, points) {\n    for (let i = 0; i < polygon.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n            if (distance(polygon[i], points[j]) < 0.00000001)\n                polygon[i] = points[j];\n        }\n    }\n    return polygon;\n}\nfunction distance(p1, p2) {\n    const dx = Math.abs(p1.x - p2.x);\n    const dy = Math.abs(p1.y - p2.y);\n    return Math.sqrt(dx * dx + dy * dy);\n}\nfunction checkPolygons(fig1, fig2) {\n    const figs = [fig1, fig2];\n    for (let i = 0; i < figs.length; i++) {\n        if (figs[i].length < 3) {\n            console.error(\"Polygon \" + (i + 1) + \" is invalid!\");\n            return false;\n        }\n    }\n    return true;\n}\nfunction edgify(fig1, fig2) {\n    const primEdges = getEdges(fig1).concat(getEdges(fig2));\n    const secEdges = [];\n    let startPoint;\n    let endPoint;\n    for (let i = 0; i < primEdges.length; i++) {\n        let points = [];\n        for (let j = 0; j < primEdges.length; j++) {\n            if (i != j) {\n                const interPoints = findEdgeIntersection(primEdges[i], primEdges[j]);\n                addNewPoints(interPoints, points);\n            }\n        }\n        startPoint = primEdges[i][0];\n        startPoint.t = 0;\n        endPoint = primEdges[i][1];\n        endPoint.t = 1;\n        addNewPoints([startPoint, endPoint], points);\n        points = sortPoints(points);\n        for (let k = 0; k < points.length - 1; k++) {\n            const edge = [\n                { x: points[k].x, y: points[k].y },\n                { x: points[k + 1].x, y: points[k + 1].y },\n            ];\n            if (!edgeExists(edge, secEdges)) {\n                secEdges.push(edge);\n            }\n        }\n    }\n    return secEdges;\n}\nfunction addNewPoints(newPoints, points) {\n    if (newPoints.length > 0) {\n        for (let k = 0; k < newPoints.length; k++) {\n            if (!pointExists(newPoints[k], points)) {\n                points.push(newPoints[k]);\n            }\n        }\n    }\n}\nfunction sortPoints(points) {\n    const p = points;\n    p.sort((a, b) => {\n        if (a.t > b.t)\n            return 1;\n        if (a.t < b.t)\n            return -1;\n        return 0;\n    });\n    return p;\n}\nfunction getEdges(fig) {\n    if (!fig) {\n        return [];\n    }\n    const edges = [];\n    const len = fig.length;\n    for (let i = 0; i < len; i++) {\n        edges.push([\n            { x: fig[i % len].x, y: fig[i % len].y },\n            { x: fig[(i + 1) % len].x, y: fig[(i + 1) % len].y },\n        ]);\n    }\n    return edges;\n}\nfunction findEdgeIntersection(edge1, edge2) {\n    const x1 = edge1[0].x;\n    const x2 = edge1[1].x;\n    const x3 = edge2[0].x;\n    const x4 = edge2[1].x;\n    const y1 = edge1[0].y;\n    const y2 = edge1[1].y;\n    const y3 = edge2[0].y;\n    const y4 = edge2[1].y;\n    const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    const t1 = nom1 / denom;\n    const t2 = nom2 / denom;\n    const interPoints = [];\n    if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        return interPoints;\n    }\n    else if (nom1 === 0 && denom === 0) {\n        for (let i = 0; i < 2; i++) {\n            const classify = classifyPoint(edge2[i], edge1);\n            if (classify.loc == \"ORIGIN\" || classify.loc == \"DESTINATION\") {\n                interPoints.push({ x: edge2[i].x, y: edge2[i].y, t: classify.t });\n            }\n            else if (classify.loc == \"BETWEEN\") {\n                const x = +(x1 + classify.t * (x2 - x1)).toPrecision(9);\n                const y = +(y1 + classify.t * (y2 - y1)).toPrecision(9);\n                interPoints.push({ x: x, y: y, t: classify.t });\n            }\n        }\n        return interPoints;\n    }\n    else {\n        for (let i = 0; i < 2; i++) {\n            const classify = classifyPoint(edge2[i], edge1);\n            if (classify.loc == \"ORIGIN\" || classify.loc == \"DESTINATION\") {\n                interPoints.push({ x: edge2[i].x, y: edge2[i].y, t: classify.t });\n            }\n        }\n        if (interPoints.length > 0) {\n            return interPoints;\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(9);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(9);\n        interPoints.push({ x: x, y: y, t: t1 });\n        return interPoints;\n    }\n}\nfunction classifyPoint(p, edge) {\n    const ax = edge[1].x - edge[0].x;\n    const ay = edge[1].y - edge[0].y;\n    const bx = p.x - edge[0].x;\n    const by = p.y - edge[0].y;\n    const sa = ax * by - bx * ay;\n    if (p.x === edge[0].x && p.y === edge[0].y) {\n        return { loc: \"ORIGIN\", t: 0 };\n    }\n    if (p.x === edge[1].x && p.y === edge[1].y) {\n        return { loc: \"DESTINATION\", t: 1 };\n    }\n    let theta = (polarAngle([edge[1], edge[0]]) -\n        polarAngle([\n            { x: edge[1].x, y: edge[1].y },\n            { x: p.x, y: p.y },\n        ])) %\n        360;\n    if (theta < 0) {\n        theta = theta + 360;\n    }\n    if (sa < -0.000000001) {\n        return { loc: \"LEFT\", theta: theta };\n    }\n    if (sa > 0.000000001) {\n        return { loc: \"RIGHT\", theta: theta };\n    }\n    if (ax * bx < 0 || ay * by < 0) {\n        return { loc: \"BEHIND\", theta: theta };\n    }\n    if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        return { loc: \"BEYOND\", theta: theta };\n    }\n    let t;\n    if (ax !== 0) {\n        t = bx / ax;\n    }\n    else {\n        t = by / ay;\n    }\n    return { loc: \"BETWEEN\", t: t };\n}\nfunction polarAngle(edge) {\n    const dx = edge[1].x - edge[0].x;\n    const dy = edge[1].y - edge[0].y;\n    if (dx === 0 && dy === 0) {\n        throw new Error(\"Edge has zero length.\");\n    }\n    if (dx === 0) {\n        return dy > 0 ? 90 : 270;\n    }\n    if (dy === 0) {\n        return dx > 0 ? 0 : 180;\n    }\n    const theta = (Math.atan(dy / dx) * 360) / (2 * Math.PI);\n    if (dx > 0) {\n        return dy >= 0 ? theta : theta + 360;\n    }\n    else {\n        return theta + 180;\n    }\n}\nfunction pointExists(p, points) {\n    if (points.length === 0) {\n        return false;\n    }\n    for (let i = 0; i < points.length; i++) {\n        if (p.x === points[i].x && p.y === points[i].y) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction edgeExists(e, edges) {\n    if (edges.length === 0) {\n        return false;\n    }\n    for (let i = 0; i < edges.length; i++) {\n        if (equalEdges(e, edges[i]))\n            return true;\n    }\n    return false;\n}\nfunction equalEdges(edge1, edge2) {\n    return ((edge1[0].x === edge2[0].x &&\n        edge1[0].y === edge2[0].y &&\n        edge1[1].x === edge2[1].x &&\n        edge1[1].y === edge2[1].y) ||\n        (edge1[0].x === edge2[1].x &&\n            edge1[0].y === edge2[1].y &&\n            edge1[1].x === edge2[0].x &&\n            edge1[1].y === edge2[0].y));\n}\nfunction polygonate(edges) {\n    const polygons = [];\n    let polygon = [];\n    const len = edges.length;\n    const midpoints = getMidpoints(edges);\n    for (let i = 0; i < len - 2; i++) {\n        const org = { x: edges[i][0].x, y: edges[i][0].y };\n        const dest = { x: edges[i][1].x, y: edges[i][1].y };\n        let currentEdge = i;\n        let point;\n        let p;\n        let direction;\n        let stop;\n        for (direction = 0; direction < 2; direction++) {\n            polygon = [];\n            stop = false;\n            while ((polygon === null || polygon === void 0 ? void 0 : polygon.length) === 0 || !stop) {\n                polygon === null || polygon === void 0 ? void 0 : polygon.push({ x: org.x, y: org.y });\n                point = undefined;\n                for (let j = 0; j < len; j++) {\n                    p = undefined;\n                    if (!equalEdges(edges[j], edges[currentEdge])) {\n                        if (edges[j][0].x === dest.x && edges[j][0].y === dest.y) {\n                            p = edges[j][1];\n                        }\n                        if (edges[j][1].x === dest.x && edges[j][1].y === dest.y) {\n                            p = edges[j][0];\n                        }\n                        if (p) {\n                            const classify = classifyPoint(p, [org, dest]);\n                            if (!point ||\n                                (classify.theta < point.theta && direction === 0) ||\n                                (classify.theta > point.theta && direction === 1)) {\n                                point = { x: p.x, y: p.y, theta: classify.theta, edge: j };\n                            }\n                        }\n                    }\n                }\n                org.x = dest.x;\n                org.y = dest.y;\n                dest.x = point === null || point === void 0 ? void 0 : point.x;\n                dest.y = point === null || point === void 0 ? void 0 : point.y;\n                currentEdge = point === null || point === void 0 ? void 0 : point.edge;\n                if (equalEdges([org, dest], edges[i])) {\n                    stop = true;\n                    for (let k = 0; k < midpoints.length; k++) {\n                        if (findPointInsidePolygon(midpoints[k], polygon)) {\n                            polygon = undefined;\n                        }\n                    }\n                }\n            }\n            if (polygon && !polygonExists(polygon, polygons)) {\n                polygons.push(polygon);\n            }\n        }\n    }\n    return polygons;\n}\nfunction polygonExists(polygon, polygons) {\n    if (polygons.length === 0)\n        return false;\n    for (let i = 0; i < polygons.length; i++) {\n        if (polygon.length !== polygons[i].length) {\n        }\n        else {\n            for (let j = 0; j < polygon.length; j++) {\n                if (!pointExists(polygon[j], polygons[i]))\n                    break;\n                else {\n                    if (j === polygon.length - 1)\n                        return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction filterPolygons(polygons, fig1, fig2, mode) {\n    const filtered = [];\n    let c1, c2;\n    let point;\n    const bigPolygons = removeSmallPolygons(polygons, 0.0001);\n    for (let i = 0; i < bigPolygons.length; i++) {\n        point = getPointInsidePolygon(bigPolygons[i]);\n        c1 = findPointInsidePolygon(point, fig1);\n        c2 = findPointInsidePolygon(point, fig2);\n        if ((mode === \"intersect\" && c1 && c2) ||\n            (mode === \"cut1\" && c1 && !c2) ||\n            (mode === \"cut2\" && !c1 && c2) ||\n            (mode === \"sum\" && (c1 || c2))) {\n            filtered.push(bigPolygons[i]);\n        }\n    }\n    return filtered;\n}\nfunction removeSmallPolygons(polygons, minSize) {\n    const big = [];\n    for (let i = 0; i < polygons.length; i++) {\n        if (polygonArea(polygons[i]) >= minSize) {\n            big.push(polygons[i]);\n        }\n    }\n    return big;\n}\nfunction polygonArea(p) {\n    const len = p.length;\n    let s = 0;\n    for (let i = 0; i < len; i++) {\n        s += Math.abs(p[i % len].x * p[(i + 1) % len].y - p[i % len].y * p[(i + 1) % len].x);\n    }\n    return s / 2;\n}\nfunction getPointInsidePolygon(polygon) {\n    let point;\n    const size = getSize(polygon);\n    const edges = getEdges(polygon);\n    let y = size.y.min + (size.y.max - size.y.min) / Math.PI;\n    const dy = (size.y.max - size.y.min) / 13;\n    let line = [];\n    let points;\n    let interPoints = [];\n    let pointsOK = false;\n    while (!pointsOK) {\n        line = [\n            { x: size.x.min - 1, y: y },\n            { x: size.x.max + 1, y: y },\n        ];\n        for (let i = 0; i < edges.length; i++) {\n            points = findEdgeIntersection(line, edges[i]);\n            if (points && points.length === 1) {\n                interPoints.push(points[0]);\n            }\n        }\n        interPoints = sortPoints(interPoints);\n        for (let i = 0; i < interPoints.length - 1; i++) {\n            if (interPoints[i].t !== interPoints[i + 1].t) {\n                pointsOK = true;\n                point = { x: (interPoints[i].x + interPoints[i + 1].x) / 2, y: y };\n            }\n        }\n        y = y + dy;\n        if ((y > size.y.max || y < size.y.min) && pointsOK === false) {\n            pointsOK = true;\n            point = undefined;\n        }\n    }\n    return point;\n}\nfunction getSize(polygon) {\n    const size = {\n        x: {\n            min: polygon[0].x,\n            max: polygon[0].x,\n        },\n        y: {\n            min: polygon[0].y,\n            max: polygon[0].y,\n        },\n    };\n    for (let i = 1; i < polygon.length; i++) {\n        if (polygon[i].x < size.x.min)\n            size.x.min = polygon[i].x;\n        if (polygon[i].x > size.x.max)\n            size.x.max = polygon[i].x;\n        if (polygon[i].y < size.y.min)\n            size.y.min = polygon[i].y;\n        if (polygon[i].y > size.y.max)\n            size.y.max = polygon[i].y;\n    }\n    return size;\n}\nfunction findPointInsidePolygon(point, polygon) {\n    let cross = 0;\n    const edges = getEdges(polygon);\n    let classify;\n    let org, dest;\n    for (let i = 0; i < edges.length; i++) {\n        [org, dest] = edges[i];\n        classify = classifyPoint(point, [org, dest]);\n        if ((classify.loc === \"RIGHT\" && org.y < point.y && dest.y >= point.y) ||\n            (classify.loc === \"LEFT\" && org.y >= point.y && dest.y < point.y)) {\n            cross++;\n        }\n        if (classify.loc === \"BETWEEN\")\n            return false;\n    }\n    return !!(cross % 2);\n}\nfunction getMidpoints(edges) {\n    const midpoints = [];\n    let x, y;\n    for (let i = 0; i < edges.length; i++) {\n        x = (edges[i][0].x + edges[i][1].x) / 2;\n        y = (edges[i][0].y + edges[i][1].y) / 2;\n        midpoints.push({ x: x, y: y });\n    }\n    return midpoints;\n}\n\n\n//# sourceURL=webpack://ts-intersect/./src/solution.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;